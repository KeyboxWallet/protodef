// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
class EccGetExtendedPublicKeyReply;
class EccGetExtendedPublicKeyReplyDefaultTypeInternal;
extern EccGetExtendedPublicKeyReplyDefaultTypeInternal _EccGetExtendedPublicKeyReply_default_instance_;
class EccGetExtendedPublicKeyRequest;
class EccGetExtendedPublicKeyRequestDefaultTypeInternal;
extern EccGetExtendedPublicKeyRequestDefaultTypeInternal _EccGetExtendedPublicKeyRequest_default_instance_;
class EccGetPublicKeyReply;
class EccGetPublicKeyReplyDefaultTypeInternal;
extern EccGetPublicKeyReplyDefaultTypeInternal _EccGetPublicKeyReply_default_instance_;
class EccGetPublicKeyRequest;
class EccGetPublicKeyRequestDefaultTypeInternal;
extern EccGetPublicKeyRequestDefaultTypeInternal _EccGetPublicKeyRequest_default_instance_;
class EccMultiplyReply;
class EccMultiplyReplyDefaultTypeInternal;
extern EccMultiplyReplyDefaultTypeInternal _EccMultiplyReply_default_instance_;
class EccMultiplyRequest;
class EccMultiplyRequestDefaultTypeInternal;
extern EccMultiplyRequestDefaultTypeInternal _EccMultiplyRequest_default_instance_;
class EccSignOptions;
class EccSignOptionsDefaultTypeInternal;
extern EccSignOptionsDefaultTypeInternal _EccSignOptions_default_instance_;
class EccSignRequest;
class EccSignRequestDefaultTypeInternal;
extern EccSignRequestDefaultTypeInternal _EccSignRequest_default_instance_;
class EccSignResult;
class EccSignResultDefaultTypeInternal;
extern EccSignResultDefaultTypeInternal _EccSignResult_default_instance_;
class EraseDataRequest;
class EraseDataRequestDefaultTypeInternal;
extern EraseDataRequestDefaultTypeInternal _EraseDataRequest_default_instance_;
class GenericConfirmReply;
class GenericConfirmReplyDefaultTypeInternal;
extern GenericConfirmReplyDefaultTypeInternal _GenericConfirmReply_default_instance_;
class GetModeAndVersionReply;
class GetModeAndVersionReplyDefaultTypeInternal;
extern GetModeAndVersionReplyDefaultTypeInternal _GetModeAndVersionReply_default_instance_;
class GetModeAndVersionRequest;
class GetModeAndVersionRequestDefaultTypeInternal;
extern GetModeAndVersionRequestDefaultTypeInternal _GetModeAndVersionRequest_default_instance_;
class LockSerialNo;
class LockSerialNoDefaultTypeInternal;
extern LockSerialNoDefaultTypeInternal _LockSerialNo_default_instance_;
class RequestRejected;
class RequestRejectedDefaultTypeInternal;
extern RequestRejectedDefaultTypeInternal _RequestRejected_default_instance_;
class SendUpgradeFirmware;
class SendUpgradeFirmwareDefaultTypeInternal;
extern SendUpgradeFirmwareDefaultTypeInternal _SendUpgradeFirmware_default_instance_;
class UpgradeStartRequest;
class UpgradeStartRequestDefaultTypeInternal;
extern UpgradeStartRequestDefaultTypeInternal _UpgradeStartRequest_default_instance_;
class WriteSerialNo;
class WriteSerialNoDefaultTypeInternal;
extern WriteSerialNoDefaultTypeInternal _WriteSerialNo_default_instance_;
class WriteSerialNoReply;
class WriteSerialNoReplyDefaultTypeInternal;
extern WriteSerialNoReplyDefaultTypeInternal _WriteSerialNoReply_default_instance_;
class lockSerialNoReply;
class lockSerialNoReplyDefaultTypeInternal;
extern lockSerialNoReplyDefaultTypeInternal _lockSerialNoReply_default_instance_;
namespace google {
namespace protobuf {
template<> ::EccGetExtendedPublicKeyReply* Arena::CreateMaybeMessage<::EccGetExtendedPublicKeyReply>(Arena*);
template<> ::EccGetExtendedPublicKeyRequest* Arena::CreateMaybeMessage<::EccGetExtendedPublicKeyRequest>(Arena*);
template<> ::EccGetPublicKeyReply* Arena::CreateMaybeMessage<::EccGetPublicKeyReply>(Arena*);
template<> ::EccGetPublicKeyRequest* Arena::CreateMaybeMessage<::EccGetPublicKeyRequest>(Arena*);
template<> ::EccMultiplyReply* Arena::CreateMaybeMessage<::EccMultiplyReply>(Arena*);
template<> ::EccMultiplyRequest* Arena::CreateMaybeMessage<::EccMultiplyRequest>(Arena*);
template<> ::EccSignOptions* Arena::CreateMaybeMessage<::EccSignOptions>(Arena*);
template<> ::EccSignRequest* Arena::CreateMaybeMessage<::EccSignRequest>(Arena*);
template<> ::EccSignResult* Arena::CreateMaybeMessage<::EccSignResult>(Arena*);
template<> ::EraseDataRequest* Arena::CreateMaybeMessage<::EraseDataRequest>(Arena*);
template<> ::GenericConfirmReply* Arena::CreateMaybeMessage<::GenericConfirmReply>(Arena*);
template<> ::GetModeAndVersionReply* Arena::CreateMaybeMessage<::GetModeAndVersionReply>(Arena*);
template<> ::GetModeAndVersionRequest* Arena::CreateMaybeMessage<::GetModeAndVersionRequest>(Arena*);
template<> ::LockSerialNo* Arena::CreateMaybeMessage<::LockSerialNo>(Arena*);
template<> ::RequestRejected* Arena::CreateMaybeMessage<::RequestRejected>(Arena*);
template<> ::SendUpgradeFirmware* Arena::CreateMaybeMessage<::SendUpgradeFirmware>(Arena*);
template<> ::UpgradeStartRequest* Arena::CreateMaybeMessage<::UpgradeStartRequest>(Arena*);
template<> ::WriteSerialNo* Arena::CreateMaybeMessage<::WriteSerialNo>(Arena*);
template<> ::WriteSerialNoReply* Arena::CreateMaybeMessage<::WriteSerialNoReply>(Arena*);
template<> ::lockSerialNoReply* Arena::CreateMaybeMessage<::lockSerialNoReply>(Arena*);
}  // namespace protobuf
}  // namespace google

enum DeviceMode {
  MODE_BOOTLOADER = 0,
  MODE_APP = 1,
  DeviceMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DeviceMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DeviceMode_IsValid(int value);
const DeviceMode DeviceMode_MIN = MODE_BOOTLOADER;
const DeviceMode DeviceMode_MAX = MODE_APP;
const int DeviceMode_ARRAYSIZE = DeviceMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceMode_descriptor();
inline const ::std::string& DeviceMode_Name(DeviceMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceMode_descriptor(), value);
}
inline bool DeviceMode_Parse(
    const ::std::string& name, DeviceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceMode>(
    DeviceMode_descriptor(), name, value);
}
enum LockState {
  UNKOWN = 0,
  UNLOCKED = 1,
  LOCKED = 2,
  LockState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LockState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LockState_IsValid(int value);
const LockState LockState_MIN = UNKOWN;
const LockState LockState_MAX = LOCKED;
const int LockState_ARRAYSIZE = LockState_MAX + 1;

const ::google::protobuf::EnumDescriptor* LockState_descriptor();
inline const ::std::string& LockState_Name(LockState value) {
  return ::google::protobuf::internal::NameOfEnum(
    LockState_descriptor(), value);
}
inline bool LockState_Parse(
    const ::std::string& name, LockState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LockState>(
    LockState_descriptor(), name, value);
}
enum EccAlgorithm {
  SECP256K1 = 0,
  EccAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EccAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EccAlgorithm_IsValid(int value);
const EccAlgorithm EccAlgorithm_MIN = SECP256K1;
const EccAlgorithm EccAlgorithm_MAX = SECP256K1;
const int EccAlgorithm_ARRAYSIZE = EccAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* EccAlgorithm_descriptor();
inline const ::std::string& EccAlgorithm_Name(EccAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    EccAlgorithm_descriptor(), value);
}
inline bool EccAlgorithm_Parse(
    const ::std::string& name, EccAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EccAlgorithm>(
    EccAlgorithm_descriptor(), name, value);
}
// ===================================================================

class RequestRejected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestRejected) */ {
 public:
  RequestRejected();
  virtual ~RequestRejected();

  RequestRejected(const RequestRejected& from);

  inline RequestRejected& operator=(const RequestRejected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestRejected(RequestRejected&& from) noexcept
    : RequestRejected() {
    *this = ::std::move(from);
  }

  inline RequestRejected& operator=(RequestRejected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRejected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestRejected* internal_default_instance() {
    return reinterpret_cast<const RequestRejected*>(
               &_RequestRejected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RequestRejected* other);
  friend void swap(RequestRejected& a, RequestRejected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestRejected* New() const final {
    return CreateMaybeMessage<RequestRejected>(NULL);
  }

  RequestRejected* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestRejected>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestRejected& from);
  void MergeFrom(const RequestRejected& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRejected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errMessage = 3;
  void clear_errmessage();
  static const int kErrMessageFieldNumber = 3;
  const ::std::string& errmessage() const;
  void set_errmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errmessage(::std::string&& value);
  #endif
  void set_errmessage(const char* value);
  void set_errmessage(const char* value, size_t size);
  ::std::string* mutable_errmessage();
  ::std::string* release_errmessage();
  void set_allocated_errmessage(::std::string* errmessage);

  // uint32 requestId = 1;
  void clear_requestid();
  static const int kRequestIdFieldNumber = 1;
  ::google::protobuf::uint32 requestid() const;
  void set_requestid(::google::protobuf::uint32 value);

  // int32 errCode = 2;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 2;
  ::google::protobuf::int32 errcode() const;
  void set_errcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RequestRejected)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errmessage_;
  ::google::protobuf::uint32 requestid_;
  ::google::protobuf::int32 errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GenericConfirmReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GenericConfirmReply) */ {
 public:
  GenericConfirmReply();
  virtual ~GenericConfirmReply();

  GenericConfirmReply(const GenericConfirmReply& from);

  inline GenericConfirmReply& operator=(const GenericConfirmReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GenericConfirmReply(GenericConfirmReply&& from) noexcept
    : GenericConfirmReply() {
    *this = ::std::move(from);
  }

  inline GenericConfirmReply& operator=(GenericConfirmReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GenericConfirmReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericConfirmReply* internal_default_instance() {
    return reinterpret_cast<const GenericConfirmReply*>(
               &_GenericConfirmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(GenericConfirmReply* other);
  friend void swap(GenericConfirmReply& a, GenericConfirmReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GenericConfirmReply* New() const final {
    return CreateMaybeMessage<GenericConfirmReply>(NULL);
  }

  GenericConfirmReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GenericConfirmReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GenericConfirmReply& from);
  void MergeFrom(const GenericConfirmReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericConfirmReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GenericConfirmReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetModeAndVersionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetModeAndVersionRequest) */ {
 public:
  GetModeAndVersionRequest();
  virtual ~GetModeAndVersionRequest();

  GetModeAndVersionRequest(const GetModeAndVersionRequest& from);

  inline GetModeAndVersionRequest& operator=(const GetModeAndVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetModeAndVersionRequest(GetModeAndVersionRequest&& from) noexcept
    : GetModeAndVersionRequest() {
    *this = ::std::move(from);
  }

  inline GetModeAndVersionRequest& operator=(GetModeAndVersionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetModeAndVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModeAndVersionRequest* internal_default_instance() {
    return reinterpret_cast<const GetModeAndVersionRequest*>(
               &_GetModeAndVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetModeAndVersionRequest* other);
  friend void swap(GetModeAndVersionRequest& a, GetModeAndVersionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetModeAndVersionRequest* New() const final {
    return CreateMaybeMessage<GetModeAndVersionRequest>(NULL);
  }

  GetModeAndVersionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetModeAndVersionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetModeAndVersionRequest& from);
  void MergeFrom(const GetModeAndVersionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModeAndVersionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GetModeAndVersionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetModeAndVersionReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GetModeAndVersionReply) */ {
 public:
  GetModeAndVersionReply();
  virtual ~GetModeAndVersionReply();

  GetModeAndVersionReply(const GetModeAndVersionReply& from);

  inline GetModeAndVersionReply& operator=(const GetModeAndVersionReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetModeAndVersionReply(GetModeAndVersionReply&& from) noexcept
    : GetModeAndVersionReply() {
    *this = ::std::move(from);
  }

  inline GetModeAndVersionReply& operator=(GetModeAndVersionReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetModeAndVersionReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModeAndVersionReply* internal_default_instance() {
    return reinterpret_cast<const GetModeAndVersionReply*>(
               &_GetModeAndVersionReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetModeAndVersionReply* other);
  friend void swap(GetModeAndVersionReply& a, GetModeAndVersionReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetModeAndVersionReply* New() const final {
    return CreateMaybeMessage<GetModeAndVersionReply>(NULL);
  }

  GetModeAndVersionReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetModeAndVersionReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetModeAndVersionReply& from);
  void MergeFrom(const GetModeAndVersionReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModeAndVersionReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string firmwareVersion = 2;
  void clear_firmwareversion();
  static const int kFirmwareVersionFieldNumber = 2;
  const ::std::string& firmwareversion() const;
  void set_firmwareversion(const ::std::string& value);
  #if LANG_CXX11
  void set_firmwareversion(::std::string&& value);
  #endif
  void set_firmwareversion(const char* value);
  void set_firmwareversion(const char* value, size_t size);
  ::std::string* mutable_firmwareversion();
  ::std::string* release_firmwareversion();
  void set_allocated_firmwareversion(::std::string* firmwareversion);

  // string deviceSerialNo = 3;
  void clear_deviceserialno();
  static const int kDeviceSerialNoFieldNumber = 3;
  const ::std::string& deviceserialno() const;
  void set_deviceserialno(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceserialno(::std::string&& value);
  #endif
  void set_deviceserialno(const char* value);
  void set_deviceserialno(const char* value, size_t size);
  ::std::string* mutable_deviceserialno();
  ::std::string* release_deviceserialno();
  void set_allocated_deviceserialno(::std::string* deviceserialno);

  // .DeviceMode mode = 1;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::DeviceMode mode() const;
  void set_mode(::DeviceMode value);

  // .LockState isLocked = 4;
  void clear_islocked();
  static const int kIsLockedFieldNumber = 4;
  ::LockState islocked() const;
  void set_islocked(::LockState value);

  // @@protoc_insertion_point(class_scope:GetModeAndVersionReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr firmwareversion_;
  ::google::protobuf::internal::ArenaStringPtr deviceserialno_;
  int mode_;
  int islocked_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeStartRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UpgradeStartRequest) */ {
 public:
  UpgradeStartRequest();
  virtual ~UpgradeStartRequest();

  UpgradeStartRequest(const UpgradeStartRequest& from);

  inline UpgradeStartRequest& operator=(const UpgradeStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpgradeStartRequest(UpgradeStartRequest&& from) noexcept
    : UpgradeStartRequest() {
    *this = ::std::move(from);
  }

  inline UpgradeStartRequest& operator=(UpgradeStartRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpgradeStartRequest* internal_default_instance() {
    return reinterpret_cast<const UpgradeStartRequest*>(
               &_UpgradeStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UpgradeStartRequest* other);
  friend void swap(UpgradeStartRequest& a, UpgradeStartRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpgradeStartRequest* New() const final {
    return CreateMaybeMessage<UpgradeStartRequest>(NULL);
  }

  UpgradeStartRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpgradeStartRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpgradeStartRequest& from);
  void MergeFrom(const UpgradeStartRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpgradeStartRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string firmwareVersion = 1;
  void clear_firmwareversion();
  static const int kFirmwareVersionFieldNumber = 1;
  const ::std::string& firmwareversion() const;
  void set_firmwareversion(const ::std::string& value);
  #if LANG_CXX11
  void set_firmwareversion(::std::string&& value);
  #endif
  void set_firmwareversion(const char* value);
  void set_firmwareversion(const char* value, size_t size);
  ::std::string* mutable_firmwareversion();
  ::std::string* release_firmwareversion();
  void set_allocated_firmwareversion(::std::string* firmwareversion);

  // bytes sha256hash = 2;
  void clear_sha256hash();
  static const int kSha256HashFieldNumber = 2;
  const ::std::string& sha256hash() const;
  void set_sha256hash(const ::std::string& value);
  #if LANG_CXX11
  void set_sha256hash(::std::string&& value);
  #endif
  void set_sha256hash(const char* value);
  void set_sha256hash(const void* value, size_t size);
  ::std::string* mutable_sha256hash();
  ::std::string* release_sha256hash();
  void set_allocated_sha256hash(::std::string* sha256hash);

  // @@protoc_insertion_point(class_scope:UpgradeStartRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr firmwareversion_;
  ::google::protobuf::internal::ArenaStringPtr sha256hash_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendUpgradeFirmware : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SendUpgradeFirmware) */ {
 public:
  SendUpgradeFirmware();
  virtual ~SendUpgradeFirmware();

  SendUpgradeFirmware(const SendUpgradeFirmware& from);

  inline SendUpgradeFirmware& operator=(const SendUpgradeFirmware& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendUpgradeFirmware(SendUpgradeFirmware&& from) noexcept
    : SendUpgradeFirmware() {
    *this = ::std::move(from);
  }

  inline SendUpgradeFirmware& operator=(SendUpgradeFirmware&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendUpgradeFirmware& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendUpgradeFirmware* internal_default_instance() {
    return reinterpret_cast<const SendUpgradeFirmware*>(
               &_SendUpgradeFirmware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(SendUpgradeFirmware* other);
  friend void swap(SendUpgradeFirmware& a, SendUpgradeFirmware& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendUpgradeFirmware* New() const final {
    return CreateMaybeMessage<SendUpgradeFirmware>(NULL);
  }

  SendUpgradeFirmware* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendUpgradeFirmware>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendUpgradeFirmware& from);
  void MergeFrom(const SendUpgradeFirmware& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendUpgradeFirmware* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string firmwareVersion = 1;
  void clear_firmwareversion();
  static const int kFirmwareVersionFieldNumber = 1;
  const ::std::string& firmwareversion() const;
  void set_firmwareversion(const ::std::string& value);
  #if LANG_CXX11
  void set_firmwareversion(::std::string&& value);
  #endif
  void set_firmwareversion(const char* value);
  void set_firmwareversion(const char* value, size_t size);
  ::std::string* mutable_firmwareversion();
  ::std::string* release_firmwareversion();
  void set_allocated_firmwareversion(::std::string* firmwareversion);

  // bytes sha256hash = 2;
  void clear_sha256hash();
  static const int kSha256HashFieldNumber = 2;
  const ::std::string& sha256hash() const;
  void set_sha256hash(const ::std::string& value);
  #if LANG_CXX11
  void set_sha256hash(::std::string&& value);
  #endif
  void set_sha256hash(const char* value);
  void set_sha256hash(const void* value, size_t size);
  ::std::string* mutable_sha256hash();
  ::std::string* release_sha256hash();
  void set_allocated_sha256hash(::std::string* sha256hash);

  // bytes signature = 3;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // bytes firmware = 4;
  void clear_firmware();
  static const int kFirmwareFieldNumber = 4;
  const ::std::string& firmware() const;
  void set_firmware(const ::std::string& value);
  #if LANG_CXX11
  void set_firmware(::std::string&& value);
  #endif
  void set_firmware(const char* value);
  void set_firmware(const void* value, size_t size);
  ::std::string* mutable_firmware();
  ::std::string* release_firmware();
  void set_allocated_firmware(::std::string* firmware);

  // @@protoc_insertion_point(class_scope:SendUpgradeFirmware)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr firmwareversion_;
  ::google::protobuf::internal::ArenaStringPtr sha256hash_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr firmware_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteSerialNo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WriteSerialNo) */ {
 public:
  WriteSerialNo();
  virtual ~WriteSerialNo();

  WriteSerialNo(const WriteSerialNo& from);

  inline WriteSerialNo& operator=(const WriteSerialNo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteSerialNo(WriteSerialNo&& from) noexcept
    : WriteSerialNo() {
    *this = ::std::move(from);
  }

  inline WriteSerialNo& operator=(WriteSerialNo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteSerialNo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteSerialNo* internal_default_instance() {
    return reinterpret_cast<const WriteSerialNo*>(
               &_WriteSerialNo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WriteSerialNo* other);
  friend void swap(WriteSerialNo& a, WriteSerialNo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteSerialNo* New() const final {
    return CreateMaybeMessage<WriteSerialNo>(NULL);
  }

  WriteSerialNo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteSerialNo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteSerialNo& from);
  void MergeFrom(const WriteSerialNo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteSerialNo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string deviceSerialNo = 1;
  void clear_deviceserialno();
  static const int kDeviceSerialNoFieldNumber = 1;
  const ::std::string& deviceserialno() const;
  void set_deviceserialno(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceserialno(::std::string&& value);
  #endif
  void set_deviceserialno(const char* value);
  void set_deviceserialno(const char* value, size_t size);
  ::std::string* mutable_deviceserialno();
  ::std::string* release_deviceserialno();
  void set_allocated_deviceserialno(::std::string* deviceserialno);

  // @@protoc_insertion_point(class_scope:WriteSerialNo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr deviceserialno_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteSerialNoReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WriteSerialNoReply) */ {
 public:
  WriteSerialNoReply();
  virtual ~WriteSerialNoReply();

  WriteSerialNoReply(const WriteSerialNoReply& from);

  inline WriteSerialNoReply& operator=(const WriteSerialNoReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteSerialNoReply(WriteSerialNoReply&& from) noexcept
    : WriteSerialNoReply() {
    *this = ::std::move(from);
  }

  inline WriteSerialNoReply& operator=(WriteSerialNoReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteSerialNoReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteSerialNoReply* internal_default_instance() {
    return reinterpret_cast<const WriteSerialNoReply*>(
               &_WriteSerialNoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WriteSerialNoReply* other);
  friend void swap(WriteSerialNoReply& a, WriteSerialNoReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteSerialNoReply* New() const final {
    return CreateMaybeMessage<WriteSerialNoReply>(NULL);
  }

  WriteSerialNoReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteSerialNoReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteSerialNoReply& from);
  void MergeFrom(const WriteSerialNoReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteSerialNoReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string deviceSerialNo = 2;
  void clear_deviceserialno();
  static const int kDeviceSerialNoFieldNumber = 2;
  const ::std::string& deviceserialno() const;
  void set_deviceserialno(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceserialno(::std::string&& value);
  #endif
  void set_deviceserialno(const char* value);
  void set_deviceserialno(const char* value, size_t size);
  ::std::string* mutable_deviceserialno();
  ::std::string* release_deviceserialno();
  void set_allocated_deviceserialno(::std::string* deviceserialno);

  // bool writeSuccess = 1;
  void clear_writesuccess();
  static const int kWriteSuccessFieldNumber = 1;
  bool writesuccess() const;
  void set_writesuccess(bool value);

  // @@protoc_insertion_point(class_scope:WriteSerialNoReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr deviceserialno_;
  bool writesuccess_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockSerialNo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LockSerialNo) */ {
 public:
  LockSerialNo();
  virtual ~LockSerialNo();

  LockSerialNo(const LockSerialNo& from);

  inline LockSerialNo& operator=(const LockSerialNo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockSerialNo(LockSerialNo&& from) noexcept
    : LockSerialNo() {
    *this = ::std::move(from);
  }

  inline LockSerialNo& operator=(LockSerialNo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockSerialNo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockSerialNo* internal_default_instance() {
    return reinterpret_cast<const LockSerialNo*>(
               &_LockSerialNo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(LockSerialNo* other);
  friend void swap(LockSerialNo& a, LockSerialNo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockSerialNo* New() const final {
    return CreateMaybeMessage<LockSerialNo>(NULL);
  }

  LockSerialNo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockSerialNo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockSerialNo& from);
  void MergeFrom(const LockSerialNo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockSerialNo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:LockSerialNo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class lockSerialNoReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lockSerialNoReply) */ {
 public:
  lockSerialNoReply();
  virtual ~lockSerialNoReply();

  lockSerialNoReply(const lockSerialNoReply& from);

  inline lockSerialNoReply& operator=(const lockSerialNoReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  lockSerialNoReply(lockSerialNoReply&& from) noexcept
    : lockSerialNoReply() {
    *this = ::std::move(from);
  }

  inline lockSerialNoReply& operator=(lockSerialNoReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const lockSerialNoReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const lockSerialNoReply* internal_default_instance() {
    return reinterpret_cast<const lockSerialNoReply*>(
               &_lockSerialNoReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(lockSerialNoReply* other);
  friend void swap(lockSerialNoReply& a, lockSerialNoReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline lockSerialNoReply* New() const final {
    return CreateMaybeMessage<lockSerialNoReply>(NULL);
  }

  lockSerialNoReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<lockSerialNoReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const lockSerialNoReply& from);
  void MergeFrom(const lockSerialNoReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(lockSerialNoReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string deviceSerialNo = 2;
  void clear_deviceserialno();
  static const int kDeviceSerialNoFieldNumber = 2;
  const ::std::string& deviceserialno() const;
  void set_deviceserialno(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceserialno(::std::string&& value);
  #endif
  void set_deviceserialno(const char* value);
  void set_deviceserialno(const char* value, size_t size);
  ::std::string* mutable_deviceserialno();
  ::std::string* release_deviceserialno();
  void set_allocated_deviceserialno(::std::string* deviceserialno);

  // bool lockSuccess = 1;
  void clear_locksuccess();
  static const int kLockSuccessFieldNumber = 1;
  bool locksuccess() const;
  void set_locksuccess(bool value);

  // @@protoc_insertion_point(class_scope:lockSerialNoReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr deviceserialno_;
  bool locksuccess_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccSignOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccSignOptions) */ {
 public:
  EccSignOptions();
  virtual ~EccSignOptions();

  EccSignOptions(const EccSignOptions& from);

  inline EccSignOptions& operator=(const EccSignOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccSignOptions(EccSignOptions&& from) noexcept
    : EccSignOptions() {
    *this = ::std::move(from);
  }

  inline EccSignOptions& operator=(EccSignOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccSignOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccSignOptions* internal_default_instance() {
    return reinterpret_cast<const EccSignOptions*>(
               &_EccSignOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(EccSignOptions* other);
  friend void swap(EccSignOptions& a, EccSignOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccSignOptions* New() const final {
    return CreateMaybeMessage<EccSignOptions>(NULL);
  }

  EccSignOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccSignOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccSignOptions& from);
  void MergeFrom(const EccSignOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccSignOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool rfc6979 = 1;
  void clear_rfc6979();
  static const int kRfc6979FieldNumber = 1;
  bool rfc6979() const;
  void set_rfc6979(bool value);

  // bool graphene_canonize = 2;
  void clear_graphene_canonize();
  static const int kGrapheneCanonizeFieldNumber = 2;
  bool graphene_canonize() const;
  void set_graphene_canonize(bool value);

  // @@protoc_insertion_point(class_scope:EccSignOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool rfc6979_;
  bool graphene_canonize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccSignRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccSignRequest) */ {
 public:
  EccSignRequest();
  virtual ~EccSignRequest();

  EccSignRequest(const EccSignRequest& from);

  inline EccSignRequest& operator=(const EccSignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccSignRequest(EccSignRequest&& from) noexcept
    : EccSignRequest() {
    *this = ::std::move(from);
  }

  inline EccSignRequest& operator=(EccSignRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccSignRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccSignRequest* internal_default_instance() {
    return reinterpret_cast<const EccSignRequest*>(
               &_EccSignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(EccSignRequest* other);
  friend void swap(EccSignRequest& a, EccSignRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccSignRequest* New() const final {
    return CreateMaybeMessage<EccSignRequest>(NULL);
  }

  EccSignRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccSignRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccSignRequest& from);
  void MergeFrom(const EccSignRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccSignRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .EccSignOptions options = 4;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 4;
  private:
  const ::EccSignOptions& _internal_options() const;
  public:
  const ::EccSignOptions& options() const;
  ::EccSignOptions* release_options();
  ::EccSignOptions* mutable_options();
  void set_allocated_options(::EccSignOptions* options);

  // .EccAlgorithm algorithm = 3;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 3;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccSignRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::EccSignOptions* options_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccSignResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccSignResult) */ {
 public:
  EccSignResult();
  virtual ~EccSignResult();

  EccSignResult(const EccSignResult& from);

  inline EccSignResult& operator=(const EccSignResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccSignResult(EccSignResult&& from) noexcept
    : EccSignResult() {
    *this = ::std::move(from);
  }

  inline EccSignResult& operator=(EccSignResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccSignResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccSignResult* internal_default_instance() {
    return reinterpret_cast<const EccSignResult*>(
               &_EccSignResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(EccSignResult* other);
  friend void swap(EccSignResult& a, EccSignResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccSignResult* New() const final {
    return CreateMaybeMessage<EccSignResult>(NULL);
  }

  EccSignResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccSignResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccSignResult& from);
  void MergeFrom(const EccSignResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccSignResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes pubkey = 2;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 2;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // bytes hash = 3;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // bytes R = 4;
  void clear_r();
  static const int kRFieldNumber = 4;
  const ::std::string& r() const;
  void set_r(const ::std::string& value);
  #if LANG_CXX11
  void set_r(::std::string&& value);
  #endif
  void set_r(const char* value);
  void set_r(const void* value, size_t size);
  ::std::string* mutable_r();
  ::std::string* release_r();
  void set_allocated_r(::std::string* r);

  // bytes S = 5;
  void clear_s();
  static const int kSFieldNumber = 5;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // uint32 recover_param = 6;
  void clear_recover_param();
  static const int kRecoverParamFieldNumber = 6;
  ::google::protobuf::uint32 recover_param() const;
  void set_recover_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:EccSignResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr r_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::google::protobuf::uint32 recover_param_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccGetPublicKeyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccGetPublicKeyRequest) */ {
 public:
  EccGetPublicKeyRequest();
  virtual ~EccGetPublicKeyRequest();

  EccGetPublicKeyRequest(const EccGetPublicKeyRequest& from);

  inline EccGetPublicKeyRequest& operator=(const EccGetPublicKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccGetPublicKeyRequest(EccGetPublicKeyRequest&& from) noexcept
    : EccGetPublicKeyRequest() {
    *this = ::std::move(from);
  }

  inline EccGetPublicKeyRequest& operator=(EccGetPublicKeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccGetPublicKeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccGetPublicKeyRequest* internal_default_instance() {
    return reinterpret_cast<const EccGetPublicKeyRequest*>(
               &_EccGetPublicKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(EccGetPublicKeyRequest* other);
  friend void swap(EccGetPublicKeyRequest& a, EccGetPublicKeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccGetPublicKeyRequest* New() const final {
    return CreateMaybeMessage<EccGetPublicKeyRequest>(NULL);
  }

  EccGetPublicKeyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccGetPublicKeyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccGetPublicKeyRequest& from);
  void MergeFrom(const EccGetPublicKeyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccGetPublicKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccGetPublicKeyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccGetPublicKeyReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccGetPublicKeyReply) */ {
 public:
  EccGetPublicKeyReply();
  virtual ~EccGetPublicKeyReply();

  EccGetPublicKeyReply(const EccGetPublicKeyReply& from);

  inline EccGetPublicKeyReply& operator=(const EccGetPublicKeyReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccGetPublicKeyReply(EccGetPublicKeyReply&& from) noexcept
    : EccGetPublicKeyReply() {
    *this = ::std::move(from);
  }

  inline EccGetPublicKeyReply& operator=(EccGetPublicKeyReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccGetPublicKeyReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccGetPublicKeyReply* internal_default_instance() {
    return reinterpret_cast<const EccGetPublicKeyReply*>(
               &_EccGetPublicKeyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(EccGetPublicKeyReply* other);
  friend void swap(EccGetPublicKeyReply& a, EccGetPublicKeyReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccGetPublicKeyReply* New() const final {
    return CreateMaybeMessage<EccGetPublicKeyReply>(NULL);
  }

  EccGetPublicKeyReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccGetPublicKeyReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccGetPublicKeyReply& from);
  void MergeFrom(const EccGetPublicKeyReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccGetPublicKeyReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes pubkey = 3;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccGetPublicKeyReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccGetExtendedPublicKeyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccGetExtendedPublicKeyRequest) */ {
 public:
  EccGetExtendedPublicKeyRequest();
  virtual ~EccGetExtendedPublicKeyRequest();

  EccGetExtendedPublicKeyRequest(const EccGetExtendedPublicKeyRequest& from);

  inline EccGetExtendedPublicKeyRequest& operator=(const EccGetExtendedPublicKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccGetExtendedPublicKeyRequest(EccGetExtendedPublicKeyRequest&& from) noexcept
    : EccGetExtendedPublicKeyRequest() {
    *this = ::std::move(from);
  }

  inline EccGetExtendedPublicKeyRequest& operator=(EccGetExtendedPublicKeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccGetExtendedPublicKeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccGetExtendedPublicKeyRequest* internal_default_instance() {
    return reinterpret_cast<const EccGetExtendedPublicKeyRequest*>(
               &_EccGetExtendedPublicKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(EccGetExtendedPublicKeyRequest* other);
  friend void swap(EccGetExtendedPublicKeyRequest& a, EccGetExtendedPublicKeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccGetExtendedPublicKeyRequest* New() const final {
    return CreateMaybeMessage<EccGetExtendedPublicKeyRequest>(NULL);
  }

  EccGetExtendedPublicKeyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccGetExtendedPublicKeyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccGetExtendedPublicKeyRequest& from);
  void MergeFrom(const EccGetExtendedPublicKeyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccGetExtendedPublicKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccGetExtendedPublicKeyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccGetExtendedPublicKeyReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccGetExtendedPublicKeyReply) */ {
 public:
  EccGetExtendedPublicKeyReply();
  virtual ~EccGetExtendedPublicKeyReply();

  EccGetExtendedPublicKeyReply(const EccGetExtendedPublicKeyReply& from);

  inline EccGetExtendedPublicKeyReply& operator=(const EccGetExtendedPublicKeyReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccGetExtendedPublicKeyReply(EccGetExtendedPublicKeyReply&& from) noexcept
    : EccGetExtendedPublicKeyReply() {
    *this = ::std::move(from);
  }

  inline EccGetExtendedPublicKeyReply& operator=(EccGetExtendedPublicKeyReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccGetExtendedPublicKeyReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccGetExtendedPublicKeyReply* internal_default_instance() {
    return reinterpret_cast<const EccGetExtendedPublicKeyReply*>(
               &_EccGetExtendedPublicKeyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(EccGetExtendedPublicKeyReply* other);
  friend void swap(EccGetExtendedPublicKeyReply& a, EccGetExtendedPublicKeyReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccGetExtendedPublicKeyReply* New() const final {
    return CreateMaybeMessage<EccGetExtendedPublicKeyReply>(NULL);
  }

  EccGetExtendedPublicKeyReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccGetExtendedPublicKeyReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccGetExtendedPublicKeyReply& from);
  void MergeFrom(const EccGetExtendedPublicKeyReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccGetExtendedPublicKeyReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes pubkey = 3;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // bytes chainCode = 4;
  void clear_chaincode();
  static const int kChainCodeFieldNumber = 4;
  const ::std::string& chaincode() const;
  void set_chaincode(const ::std::string& value);
  #if LANG_CXX11
  void set_chaincode(::std::string&& value);
  #endif
  void set_chaincode(const char* value);
  void set_chaincode(const void* value, size_t size);
  ::std::string* mutable_chaincode();
  ::std::string* release_chaincode();
  void set_allocated_chaincode(::std::string* chaincode);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccGetExtendedPublicKeyReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr chaincode_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccMultiplyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccMultiplyRequest) */ {
 public:
  EccMultiplyRequest();
  virtual ~EccMultiplyRequest();

  EccMultiplyRequest(const EccMultiplyRequest& from);

  inline EccMultiplyRequest& operator=(const EccMultiplyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccMultiplyRequest(EccMultiplyRequest&& from) noexcept
    : EccMultiplyRequest() {
    *this = ::std::move(from);
  }

  inline EccMultiplyRequest& operator=(EccMultiplyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccMultiplyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccMultiplyRequest* internal_default_instance() {
    return reinterpret_cast<const EccMultiplyRequest*>(
               &_EccMultiplyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(EccMultiplyRequest* other);
  friend void swap(EccMultiplyRequest& a, EccMultiplyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccMultiplyRequest* New() const final {
    return CreateMaybeMessage<EccMultiplyRequest>(NULL);
  }

  EccMultiplyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccMultiplyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccMultiplyRequest& from);
  void MergeFrom(const EccMultiplyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccMultiplyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes input_pubkey = 3;
  void clear_input_pubkey();
  static const int kInputPubkeyFieldNumber = 3;
  const ::std::string& input_pubkey() const;
  void set_input_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_input_pubkey(::std::string&& value);
  #endif
  void set_input_pubkey(const char* value);
  void set_input_pubkey(const void* value, size_t size);
  ::std::string* mutable_input_pubkey();
  ::std::string* release_input_pubkey();
  void set_allocated_input_pubkey(::std::string* input_pubkey);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccMultiplyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr input_pubkey_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EccMultiplyReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EccMultiplyReply) */ {
 public:
  EccMultiplyReply();
  virtual ~EccMultiplyReply();

  EccMultiplyReply(const EccMultiplyReply& from);

  inline EccMultiplyReply& operator=(const EccMultiplyReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EccMultiplyReply(EccMultiplyReply&& from) noexcept
    : EccMultiplyReply() {
    *this = ::std::move(from);
  }

  inline EccMultiplyReply& operator=(EccMultiplyReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EccMultiplyReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EccMultiplyReply* internal_default_instance() {
    return reinterpret_cast<const EccMultiplyReply*>(
               &_EccMultiplyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(EccMultiplyReply* other);
  friend void swap(EccMultiplyReply& a, EccMultiplyReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EccMultiplyReply* New() const final {
    return CreateMaybeMessage<EccMultiplyReply>(NULL);
  }

  EccMultiplyReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EccMultiplyReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EccMultiplyReply& from);
  void MergeFrom(const EccMultiplyReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EccMultiplyReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hdPath = 1;
  void clear_hdpath();
  static const int kHdPathFieldNumber = 1;
  const ::std::string& hdpath() const;
  void set_hdpath(const ::std::string& value);
  #if LANG_CXX11
  void set_hdpath(::std::string&& value);
  #endif
  void set_hdpath(const char* value);
  void set_hdpath(const char* value, size_t size);
  ::std::string* mutable_hdpath();
  ::std::string* release_hdpath();
  void set_allocated_hdpath(::std::string* hdpath);

  // bytes input_pubkey = 3;
  void clear_input_pubkey();
  static const int kInputPubkeyFieldNumber = 3;
  const ::std::string& input_pubkey() const;
  void set_input_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_input_pubkey(::std::string&& value);
  #endif
  void set_input_pubkey(const char* value);
  void set_input_pubkey(const void* value, size_t size);
  ::std::string* mutable_input_pubkey();
  ::std::string* release_input_pubkey();
  void set_allocated_input_pubkey(::std::string* input_pubkey);

  // bytes dev_pubkey = 4;
  void clear_dev_pubkey();
  static const int kDevPubkeyFieldNumber = 4;
  const ::std::string& dev_pubkey() const;
  void set_dev_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_dev_pubkey(::std::string&& value);
  #endif
  void set_dev_pubkey(const char* value);
  void set_dev_pubkey(const void* value, size_t size);
  ::std::string* mutable_dev_pubkey();
  ::std::string* release_dev_pubkey();
  void set_allocated_dev_pubkey(::std::string* dev_pubkey);

  // bytes result = 5;
  void clear_result();
  static const int kResultFieldNumber = 5;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  #if LANG_CXX11
  void set_result(::std::string&& value);
  #endif
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // .EccAlgorithm algorithm = 2;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  ::EccAlgorithm algorithm() const;
  void set_algorithm(::EccAlgorithm value);

  // @@protoc_insertion_point(class_scope:EccMultiplyReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hdpath_;
  ::google::protobuf::internal::ArenaStringPtr input_pubkey_;
  ::google::protobuf::internal::ArenaStringPtr dev_pubkey_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  int algorithm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EraseDataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EraseDataRequest) */ {
 public:
  EraseDataRequest();
  virtual ~EraseDataRequest();

  EraseDataRequest(const EraseDataRequest& from);

  inline EraseDataRequest& operator=(const EraseDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EraseDataRequest(EraseDataRequest&& from) noexcept
    : EraseDataRequest() {
    *this = ::std::move(from);
  }

  inline EraseDataRequest& operator=(EraseDataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EraseDataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EraseDataRequest* internal_default_instance() {
    return reinterpret_cast<const EraseDataRequest*>(
               &_EraseDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(EraseDataRequest* other);
  friend void swap(EraseDataRequest& a, EraseDataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EraseDataRequest* New() const final {
    return CreateMaybeMessage<EraseDataRequest>(NULL);
  }

  EraseDataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EraseDataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EraseDataRequest& from);
  void MergeFrom(const EraseDataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EraseDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EraseDataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestRejected

// uint32 requestId = 1;
inline void RequestRejected::clear_requestid() {
  requestid_ = 0u;
}
inline ::google::protobuf::uint32 RequestRejected::requestid() const {
  // @@protoc_insertion_point(field_get:RequestRejected.requestId)
  return requestid_;
}
inline void RequestRejected::set_requestid(::google::protobuf::uint32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:RequestRejected.requestId)
}

// int32 errCode = 2;
inline void RequestRejected::clear_errcode() {
  errcode_ = 0;
}
inline ::google::protobuf::int32 RequestRejected::errcode() const {
  // @@protoc_insertion_point(field_get:RequestRejected.errCode)
  return errcode_;
}
inline void RequestRejected::set_errcode(::google::protobuf::int32 value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:RequestRejected.errCode)
}

// string errMessage = 3;
inline void RequestRejected::clear_errmessage() {
  errmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestRejected::errmessage() const {
  // @@protoc_insertion_point(field_get:RequestRejected.errMessage)
  return errmessage_.GetNoArena();
}
inline void RequestRejected::set_errmessage(const ::std::string& value) {
  
  errmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestRejected.errMessage)
}
#if LANG_CXX11
inline void RequestRejected::set_errmessage(::std::string&& value) {
  
  errmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RequestRejected.errMessage)
}
#endif
inline void RequestRejected::set_errmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestRejected.errMessage)
}
inline void RequestRejected::set_errmessage(const char* value, size_t size) {
  
  errmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestRejected.errMessage)
}
inline ::std::string* RequestRejected::mutable_errmessage() {
  
  // @@protoc_insertion_point(field_mutable:RequestRejected.errMessage)
  return errmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestRejected::release_errmessage() {
  // @@protoc_insertion_point(field_release:RequestRejected.errMessage)
  
  return errmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestRejected::set_allocated_errmessage(::std::string* errmessage) {
  if (errmessage != NULL) {
    
  } else {
    
  }
  errmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errmessage);
  // @@protoc_insertion_point(field_set_allocated:RequestRejected.errMessage)
}

// -------------------------------------------------------------------

// GenericConfirmReply

// -------------------------------------------------------------------

// GetModeAndVersionRequest

// -------------------------------------------------------------------

// GetModeAndVersionReply

// .DeviceMode mode = 1;
inline void GetModeAndVersionReply::clear_mode() {
  mode_ = 0;
}
inline ::DeviceMode GetModeAndVersionReply::mode() const {
  // @@protoc_insertion_point(field_get:GetModeAndVersionReply.mode)
  return static_cast< ::DeviceMode >(mode_);
}
inline void GetModeAndVersionReply::set_mode(::DeviceMode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:GetModeAndVersionReply.mode)
}

// string firmwareVersion = 2;
inline void GetModeAndVersionReply::clear_firmwareversion() {
  firmwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetModeAndVersionReply::firmwareversion() const {
  // @@protoc_insertion_point(field_get:GetModeAndVersionReply.firmwareVersion)
  return firmwareversion_.GetNoArena();
}
inline void GetModeAndVersionReply::set_firmwareversion(const ::std::string& value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GetModeAndVersionReply.firmwareVersion)
}
#if LANG_CXX11
inline void GetModeAndVersionReply::set_firmwareversion(::std::string&& value) {
  
  firmwareversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GetModeAndVersionReply.firmwareVersion)
}
#endif
inline void GetModeAndVersionReply::set_firmwareversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GetModeAndVersionReply.firmwareVersion)
}
inline void GetModeAndVersionReply::set_firmwareversion(const char* value, size_t size) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GetModeAndVersionReply.firmwareVersion)
}
inline ::std::string* GetModeAndVersionReply::mutable_firmwareversion() {
  
  // @@protoc_insertion_point(field_mutable:GetModeAndVersionReply.firmwareVersion)
  return firmwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetModeAndVersionReply::release_firmwareversion() {
  // @@protoc_insertion_point(field_release:GetModeAndVersionReply.firmwareVersion)
  
  return firmwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModeAndVersionReply::set_allocated_firmwareversion(::std::string* firmwareversion) {
  if (firmwareversion != NULL) {
    
  } else {
    
  }
  firmwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwareversion);
  // @@protoc_insertion_point(field_set_allocated:GetModeAndVersionReply.firmwareVersion)
}

// string deviceSerialNo = 3;
inline void GetModeAndVersionReply::clear_deviceserialno() {
  deviceserialno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetModeAndVersionReply::deviceserialno() const {
  // @@protoc_insertion_point(field_get:GetModeAndVersionReply.deviceSerialNo)
  return deviceserialno_.GetNoArena();
}
inline void GetModeAndVersionReply::set_deviceserialno(const ::std::string& value) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GetModeAndVersionReply.deviceSerialNo)
}
#if LANG_CXX11
inline void GetModeAndVersionReply::set_deviceserialno(::std::string&& value) {
  
  deviceserialno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GetModeAndVersionReply.deviceSerialNo)
}
#endif
inline void GetModeAndVersionReply::set_deviceserialno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GetModeAndVersionReply.deviceSerialNo)
}
inline void GetModeAndVersionReply::set_deviceserialno(const char* value, size_t size) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GetModeAndVersionReply.deviceSerialNo)
}
inline ::std::string* GetModeAndVersionReply::mutable_deviceserialno() {
  
  // @@protoc_insertion_point(field_mutable:GetModeAndVersionReply.deviceSerialNo)
  return deviceserialno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetModeAndVersionReply::release_deviceserialno() {
  // @@protoc_insertion_point(field_release:GetModeAndVersionReply.deviceSerialNo)
  
  return deviceserialno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModeAndVersionReply::set_allocated_deviceserialno(::std::string* deviceserialno) {
  if (deviceserialno != NULL) {
    
  } else {
    
  }
  deviceserialno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceserialno);
  // @@protoc_insertion_point(field_set_allocated:GetModeAndVersionReply.deviceSerialNo)
}

// .LockState isLocked = 4;
inline void GetModeAndVersionReply::clear_islocked() {
  islocked_ = 0;
}
inline ::LockState GetModeAndVersionReply::islocked() const {
  // @@protoc_insertion_point(field_get:GetModeAndVersionReply.isLocked)
  return static_cast< ::LockState >(islocked_);
}
inline void GetModeAndVersionReply::set_islocked(::LockState value) {
  
  islocked_ = value;
  // @@protoc_insertion_point(field_set:GetModeAndVersionReply.isLocked)
}

// -------------------------------------------------------------------

// UpgradeStartRequest

// string firmwareVersion = 1;
inline void UpgradeStartRequest::clear_firmwareversion() {
  firmwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpgradeStartRequest::firmwareversion() const {
  // @@protoc_insertion_point(field_get:UpgradeStartRequest.firmwareVersion)
  return firmwareversion_.GetNoArena();
}
inline void UpgradeStartRequest::set_firmwareversion(const ::std::string& value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:UpgradeStartRequest.firmwareVersion)
}
#if LANG_CXX11
inline void UpgradeStartRequest::set_firmwareversion(::std::string&& value) {
  
  firmwareversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:UpgradeStartRequest.firmwareVersion)
}
#endif
inline void UpgradeStartRequest::set_firmwareversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:UpgradeStartRequest.firmwareVersion)
}
inline void UpgradeStartRequest::set_firmwareversion(const char* value, size_t size) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:UpgradeStartRequest.firmwareVersion)
}
inline ::std::string* UpgradeStartRequest::mutable_firmwareversion() {
  
  // @@protoc_insertion_point(field_mutable:UpgradeStartRequest.firmwareVersion)
  return firmwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeStartRequest::release_firmwareversion() {
  // @@protoc_insertion_point(field_release:UpgradeStartRequest.firmwareVersion)
  
  return firmwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeStartRequest::set_allocated_firmwareversion(::std::string* firmwareversion) {
  if (firmwareversion != NULL) {
    
  } else {
    
  }
  firmwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwareversion);
  // @@protoc_insertion_point(field_set_allocated:UpgradeStartRequest.firmwareVersion)
}

// bytes sha256hash = 2;
inline void UpgradeStartRequest::clear_sha256hash() {
  sha256hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpgradeStartRequest::sha256hash() const {
  // @@protoc_insertion_point(field_get:UpgradeStartRequest.sha256hash)
  return sha256hash_.GetNoArena();
}
inline void UpgradeStartRequest::set_sha256hash(const ::std::string& value) {
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:UpgradeStartRequest.sha256hash)
}
#if LANG_CXX11
inline void UpgradeStartRequest::set_sha256hash(::std::string&& value) {
  
  sha256hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:UpgradeStartRequest.sha256hash)
}
#endif
inline void UpgradeStartRequest::set_sha256hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:UpgradeStartRequest.sha256hash)
}
inline void UpgradeStartRequest::set_sha256hash(const void* value, size_t size) {
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:UpgradeStartRequest.sha256hash)
}
inline ::std::string* UpgradeStartRequest::mutable_sha256hash() {
  
  // @@protoc_insertion_point(field_mutable:UpgradeStartRequest.sha256hash)
  return sha256hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeStartRequest::release_sha256hash() {
  // @@protoc_insertion_point(field_release:UpgradeStartRequest.sha256hash)
  
  return sha256hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeStartRequest::set_allocated_sha256hash(::std::string* sha256hash) {
  if (sha256hash != NULL) {
    
  } else {
    
  }
  sha256hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256hash);
  // @@protoc_insertion_point(field_set_allocated:UpgradeStartRequest.sha256hash)
}

// -------------------------------------------------------------------

// SendUpgradeFirmware

// string firmwareVersion = 1;
inline void SendUpgradeFirmware::clear_firmwareversion() {
  firmwareversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendUpgradeFirmware::firmwareversion() const {
  // @@protoc_insertion_point(field_get:SendUpgradeFirmware.firmwareVersion)
  return firmwareversion_.GetNoArena();
}
inline void SendUpgradeFirmware::set_firmwareversion(const ::std::string& value) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SendUpgradeFirmware.firmwareVersion)
}
#if LANG_CXX11
inline void SendUpgradeFirmware::set_firmwareversion(::std::string&& value) {
  
  firmwareversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SendUpgradeFirmware.firmwareVersion)
}
#endif
inline void SendUpgradeFirmware::set_firmwareversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SendUpgradeFirmware.firmwareVersion)
}
inline void SendUpgradeFirmware::set_firmwareversion(const char* value, size_t size) {
  
  firmwareversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SendUpgradeFirmware.firmwareVersion)
}
inline ::std::string* SendUpgradeFirmware::mutable_firmwareversion() {
  
  // @@protoc_insertion_point(field_mutable:SendUpgradeFirmware.firmwareVersion)
  return firmwareversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendUpgradeFirmware::release_firmwareversion() {
  // @@protoc_insertion_point(field_release:SendUpgradeFirmware.firmwareVersion)
  
  return firmwareversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendUpgradeFirmware::set_allocated_firmwareversion(::std::string* firmwareversion) {
  if (firmwareversion != NULL) {
    
  } else {
    
  }
  firmwareversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmwareversion);
  // @@protoc_insertion_point(field_set_allocated:SendUpgradeFirmware.firmwareVersion)
}

// bytes sha256hash = 2;
inline void SendUpgradeFirmware::clear_sha256hash() {
  sha256hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendUpgradeFirmware::sha256hash() const {
  // @@protoc_insertion_point(field_get:SendUpgradeFirmware.sha256hash)
  return sha256hash_.GetNoArena();
}
inline void SendUpgradeFirmware::set_sha256hash(const ::std::string& value) {
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SendUpgradeFirmware.sha256hash)
}
#if LANG_CXX11
inline void SendUpgradeFirmware::set_sha256hash(::std::string&& value) {
  
  sha256hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SendUpgradeFirmware.sha256hash)
}
#endif
inline void SendUpgradeFirmware::set_sha256hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SendUpgradeFirmware.sha256hash)
}
inline void SendUpgradeFirmware::set_sha256hash(const void* value, size_t size) {
  
  sha256hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SendUpgradeFirmware.sha256hash)
}
inline ::std::string* SendUpgradeFirmware::mutable_sha256hash() {
  
  // @@protoc_insertion_point(field_mutable:SendUpgradeFirmware.sha256hash)
  return sha256hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendUpgradeFirmware::release_sha256hash() {
  // @@protoc_insertion_point(field_release:SendUpgradeFirmware.sha256hash)
  
  return sha256hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendUpgradeFirmware::set_allocated_sha256hash(::std::string* sha256hash) {
  if (sha256hash != NULL) {
    
  } else {
    
  }
  sha256hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256hash);
  // @@protoc_insertion_point(field_set_allocated:SendUpgradeFirmware.sha256hash)
}

// bytes signature = 3;
inline void SendUpgradeFirmware::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendUpgradeFirmware::signature() const {
  // @@protoc_insertion_point(field_get:SendUpgradeFirmware.signature)
  return signature_.GetNoArena();
}
inline void SendUpgradeFirmware::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SendUpgradeFirmware.signature)
}
#if LANG_CXX11
inline void SendUpgradeFirmware::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SendUpgradeFirmware.signature)
}
#endif
inline void SendUpgradeFirmware::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SendUpgradeFirmware.signature)
}
inline void SendUpgradeFirmware::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SendUpgradeFirmware.signature)
}
inline ::std::string* SendUpgradeFirmware::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:SendUpgradeFirmware.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendUpgradeFirmware::release_signature() {
  // @@protoc_insertion_point(field_release:SendUpgradeFirmware.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendUpgradeFirmware::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:SendUpgradeFirmware.signature)
}

// bytes firmware = 4;
inline void SendUpgradeFirmware::clear_firmware() {
  firmware_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendUpgradeFirmware::firmware() const {
  // @@protoc_insertion_point(field_get:SendUpgradeFirmware.firmware)
  return firmware_.GetNoArena();
}
inline void SendUpgradeFirmware::set_firmware(const ::std::string& value) {
  
  firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SendUpgradeFirmware.firmware)
}
#if LANG_CXX11
inline void SendUpgradeFirmware::set_firmware(::std::string&& value) {
  
  firmware_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SendUpgradeFirmware.firmware)
}
#endif
inline void SendUpgradeFirmware::set_firmware(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SendUpgradeFirmware.firmware)
}
inline void SendUpgradeFirmware::set_firmware(const void* value, size_t size) {
  
  firmware_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SendUpgradeFirmware.firmware)
}
inline ::std::string* SendUpgradeFirmware::mutable_firmware() {
  
  // @@protoc_insertion_point(field_mutable:SendUpgradeFirmware.firmware)
  return firmware_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendUpgradeFirmware::release_firmware() {
  // @@protoc_insertion_point(field_release:SendUpgradeFirmware.firmware)
  
  return firmware_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendUpgradeFirmware::set_allocated_firmware(::std::string* firmware) {
  if (firmware != NULL) {
    
  } else {
    
  }
  firmware_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), firmware);
  // @@protoc_insertion_point(field_set_allocated:SendUpgradeFirmware.firmware)
}

// -------------------------------------------------------------------

// WriteSerialNo

// string deviceSerialNo = 1;
inline void WriteSerialNo::clear_deviceserialno() {
  deviceserialno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteSerialNo::deviceserialno() const {
  // @@protoc_insertion_point(field_get:WriteSerialNo.deviceSerialNo)
  return deviceserialno_.GetNoArena();
}
inline void WriteSerialNo::set_deviceserialno(const ::std::string& value) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WriteSerialNo.deviceSerialNo)
}
#if LANG_CXX11
inline void WriteSerialNo::set_deviceserialno(::std::string&& value) {
  
  deviceserialno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WriteSerialNo.deviceSerialNo)
}
#endif
inline void WriteSerialNo::set_deviceserialno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WriteSerialNo.deviceSerialNo)
}
inline void WriteSerialNo::set_deviceserialno(const char* value, size_t size) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WriteSerialNo.deviceSerialNo)
}
inline ::std::string* WriteSerialNo::mutable_deviceserialno() {
  
  // @@protoc_insertion_point(field_mutable:WriteSerialNo.deviceSerialNo)
  return deviceserialno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteSerialNo::release_deviceserialno() {
  // @@protoc_insertion_point(field_release:WriteSerialNo.deviceSerialNo)
  
  return deviceserialno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteSerialNo::set_allocated_deviceserialno(::std::string* deviceserialno) {
  if (deviceserialno != NULL) {
    
  } else {
    
  }
  deviceserialno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceserialno);
  // @@protoc_insertion_point(field_set_allocated:WriteSerialNo.deviceSerialNo)
}

// -------------------------------------------------------------------

// WriteSerialNoReply

// bool writeSuccess = 1;
inline void WriteSerialNoReply::clear_writesuccess() {
  writesuccess_ = false;
}
inline bool WriteSerialNoReply::writesuccess() const {
  // @@protoc_insertion_point(field_get:WriteSerialNoReply.writeSuccess)
  return writesuccess_;
}
inline void WriteSerialNoReply::set_writesuccess(bool value) {
  
  writesuccess_ = value;
  // @@protoc_insertion_point(field_set:WriteSerialNoReply.writeSuccess)
}

// string deviceSerialNo = 2;
inline void WriteSerialNoReply::clear_deviceserialno() {
  deviceserialno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteSerialNoReply::deviceserialno() const {
  // @@protoc_insertion_point(field_get:WriteSerialNoReply.deviceSerialNo)
  return deviceserialno_.GetNoArena();
}
inline void WriteSerialNoReply::set_deviceserialno(const ::std::string& value) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WriteSerialNoReply.deviceSerialNo)
}
#if LANG_CXX11
inline void WriteSerialNoReply::set_deviceserialno(::std::string&& value) {
  
  deviceserialno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WriteSerialNoReply.deviceSerialNo)
}
#endif
inline void WriteSerialNoReply::set_deviceserialno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WriteSerialNoReply.deviceSerialNo)
}
inline void WriteSerialNoReply::set_deviceserialno(const char* value, size_t size) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WriteSerialNoReply.deviceSerialNo)
}
inline ::std::string* WriteSerialNoReply::mutable_deviceserialno() {
  
  // @@protoc_insertion_point(field_mutable:WriteSerialNoReply.deviceSerialNo)
  return deviceserialno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteSerialNoReply::release_deviceserialno() {
  // @@protoc_insertion_point(field_release:WriteSerialNoReply.deviceSerialNo)
  
  return deviceserialno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteSerialNoReply::set_allocated_deviceserialno(::std::string* deviceserialno) {
  if (deviceserialno != NULL) {
    
  } else {
    
  }
  deviceserialno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceserialno);
  // @@protoc_insertion_point(field_set_allocated:WriteSerialNoReply.deviceSerialNo)
}

// -------------------------------------------------------------------

// LockSerialNo

// -------------------------------------------------------------------

// lockSerialNoReply

// bool lockSuccess = 1;
inline void lockSerialNoReply::clear_locksuccess() {
  locksuccess_ = false;
}
inline bool lockSerialNoReply::locksuccess() const {
  // @@protoc_insertion_point(field_get:lockSerialNoReply.lockSuccess)
  return locksuccess_;
}
inline void lockSerialNoReply::set_locksuccess(bool value) {
  
  locksuccess_ = value;
  // @@protoc_insertion_point(field_set:lockSerialNoReply.lockSuccess)
}

// string deviceSerialNo = 2;
inline void lockSerialNoReply::clear_deviceserialno() {
  deviceserialno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& lockSerialNoReply::deviceserialno() const {
  // @@protoc_insertion_point(field_get:lockSerialNoReply.deviceSerialNo)
  return deviceserialno_.GetNoArena();
}
inline void lockSerialNoReply::set_deviceserialno(const ::std::string& value) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lockSerialNoReply.deviceSerialNo)
}
#if LANG_CXX11
inline void lockSerialNoReply::set_deviceserialno(::std::string&& value) {
  
  deviceserialno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lockSerialNoReply.deviceSerialNo)
}
#endif
inline void lockSerialNoReply::set_deviceserialno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lockSerialNoReply.deviceSerialNo)
}
inline void lockSerialNoReply::set_deviceserialno(const char* value, size_t size) {
  
  deviceserialno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lockSerialNoReply.deviceSerialNo)
}
inline ::std::string* lockSerialNoReply::mutable_deviceserialno() {
  
  // @@protoc_insertion_point(field_mutable:lockSerialNoReply.deviceSerialNo)
  return deviceserialno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* lockSerialNoReply::release_deviceserialno() {
  // @@protoc_insertion_point(field_release:lockSerialNoReply.deviceSerialNo)
  
  return deviceserialno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void lockSerialNoReply::set_allocated_deviceserialno(::std::string* deviceserialno) {
  if (deviceserialno != NULL) {
    
  } else {
    
  }
  deviceserialno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceserialno);
  // @@protoc_insertion_point(field_set_allocated:lockSerialNoReply.deviceSerialNo)
}

// -------------------------------------------------------------------

// EccSignOptions

// bool rfc6979 = 1;
inline void EccSignOptions::clear_rfc6979() {
  rfc6979_ = false;
}
inline bool EccSignOptions::rfc6979() const {
  // @@protoc_insertion_point(field_get:EccSignOptions.rfc6979)
  return rfc6979_;
}
inline void EccSignOptions::set_rfc6979(bool value) {
  
  rfc6979_ = value;
  // @@protoc_insertion_point(field_set:EccSignOptions.rfc6979)
}

// bool graphene_canonize = 2;
inline void EccSignOptions::clear_graphene_canonize() {
  graphene_canonize_ = false;
}
inline bool EccSignOptions::graphene_canonize() const {
  // @@protoc_insertion_point(field_get:EccSignOptions.graphene_canonize)
  return graphene_canonize_;
}
inline void EccSignOptions::set_graphene_canonize(bool value) {
  
  graphene_canonize_ = value;
  // @@protoc_insertion_point(field_set:EccSignOptions.graphene_canonize)
}

// -------------------------------------------------------------------

// EccSignRequest

// string hdPath = 1;
inline void EccSignRequest::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignRequest::hdpath() const {
  // @@protoc_insertion_point(field_get:EccSignRequest.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccSignRequest::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignRequest.hdPath)
}
#if LANG_CXX11
inline void EccSignRequest::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignRequest.hdPath)
}
#endif
inline void EccSignRequest::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignRequest.hdPath)
}
inline void EccSignRequest::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignRequest.hdPath)
}
inline ::std::string* EccSignRequest::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccSignRequest.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignRequest::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccSignRequest.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignRequest::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccSignRequest.hdPath)
}

// bytes hash = 2;
inline void EccSignRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignRequest::hash() const {
  // @@protoc_insertion_point(field_get:EccSignRequest.hash)
  return hash_.GetNoArena();
}
inline void EccSignRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignRequest.hash)
}
#if LANG_CXX11
inline void EccSignRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignRequest.hash)
}
#endif
inline void EccSignRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignRequest.hash)
}
inline void EccSignRequest::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignRequest.hash)
}
inline ::std::string* EccSignRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:EccSignRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignRequest::release_hash() {
  // @@protoc_insertion_point(field_release:EccSignRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:EccSignRequest.hash)
}

// .EccAlgorithm algorithm = 3;
inline void EccSignRequest::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccSignRequest::algorithm() const {
  // @@protoc_insertion_point(field_get:EccSignRequest.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccSignRequest::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccSignRequest.algorithm)
}

// .EccSignOptions options = 4;
inline bool EccSignRequest::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void EccSignRequest::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::EccSignOptions& EccSignRequest::_internal_options() const {
  return *options_;
}
inline const ::EccSignOptions& EccSignRequest::options() const {
  const ::EccSignOptions* p = options_;
  // @@protoc_insertion_point(field_get:EccSignRequest.options)
  return p != NULL ? *p : *reinterpret_cast<const ::EccSignOptions*>(
      &::_EccSignOptions_default_instance_);
}
inline ::EccSignOptions* EccSignRequest::release_options() {
  // @@protoc_insertion_point(field_release:EccSignRequest.options)
  
  ::EccSignOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::EccSignOptions* EccSignRequest::mutable_options() {
  
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::EccSignOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:EccSignRequest.options)
  return options_;
}
inline void EccSignRequest::set_allocated_options(::EccSignOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:EccSignRequest.options)
}

// -------------------------------------------------------------------

// EccSignResult

// string hdPath = 1;
inline void EccSignResult::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignResult::hdpath() const {
  // @@protoc_insertion_point(field_get:EccSignResult.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccSignResult::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignResult.hdPath)
}
#if LANG_CXX11
inline void EccSignResult::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignResult.hdPath)
}
#endif
inline void EccSignResult::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignResult.hdPath)
}
inline void EccSignResult::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignResult.hdPath)
}
inline ::std::string* EccSignResult::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccSignResult.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignResult::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccSignResult.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignResult::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccSignResult.hdPath)
}

// bytes pubkey = 2;
inline void EccSignResult::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignResult::pubkey() const {
  // @@protoc_insertion_point(field_get:EccSignResult.pubkey)
  return pubkey_.GetNoArena();
}
inline void EccSignResult::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignResult.pubkey)
}
#if LANG_CXX11
inline void EccSignResult::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignResult.pubkey)
}
#endif
inline void EccSignResult::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignResult.pubkey)
}
inline void EccSignResult::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignResult.pubkey)
}
inline ::std::string* EccSignResult::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccSignResult.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignResult::release_pubkey() {
  // @@protoc_insertion_point(field_release:EccSignResult.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignResult::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccSignResult.pubkey)
}

// bytes hash = 3;
inline void EccSignResult::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignResult::hash() const {
  // @@protoc_insertion_point(field_get:EccSignResult.hash)
  return hash_.GetNoArena();
}
inline void EccSignResult::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignResult.hash)
}
#if LANG_CXX11
inline void EccSignResult::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignResult.hash)
}
#endif
inline void EccSignResult::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignResult.hash)
}
inline void EccSignResult::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignResult.hash)
}
inline ::std::string* EccSignResult::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:EccSignResult.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignResult::release_hash() {
  // @@protoc_insertion_point(field_release:EccSignResult.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignResult::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:EccSignResult.hash)
}

// bytes R = 4;
inline void EccSignResult::clear_r() {
  r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignResult::r() const {
  // @@protoc_insertion_point(field_get:EccSignResult.R)
  return r_.GetNoArena();
}
inline void EccSignResult::set_r(const ::std::string& value) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignResult.R)
}
#if LANG_CXX11
inline void EccSignResult::set_r(::std::string&& value) {
  
  r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignResult.R)
}
#endif
inline void EccSignResult::set_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignResult.R)
}
inline void EccSignResult::set_r(const void* value, size_t size) {
  
  r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignResult.R)
}
inline ::std::string* EccSignResult::mutable_r() {
  
  // @@protoc_insertion_point(field_mutable:EccSignResult.R)
  return r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignResult::release_r() {
  // @@protoc_insertion_point(field_release:EccSignResult.R)
  
  return r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignResult::set_allocated_r(::std::string* r) {
  if (r != NULL) {
    
  } else {
    
  }
  r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), r);
  // @@protoc_insertion_point(field_set_allocated:EccSignResult.R)
}

// bytes S = 5;
inline void EccSignResult::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccSignResult::s() const {
  // @@protoc_insertion_point(field_get:EccSignResult.S)
  return s_.GetNoArena();
}
inline void EccSignResult::set_s(const ::std::string& value) {
  
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccSignResult.S)
}
#if LANG_CXX11
inline void EccSignResult::set_s(::std::string&& value) {
  
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccSignResult.S)
}
#endif
inline void EccSignResult::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccSignResult.S)
}
inline void EccSignResult::set_s(const void* value, size_t size) {
  
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccSignResult.S)
}
inline ::std::string* EccSignResult::mutable_s() {
  
  // @@protoc_insertion_point(field_mutable:EccSignResult.S)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccSignResult::release_s() {
  // @@protoc_insertion_point(field_release:EccSignResult.S)
  
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccSignResult::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    
  } else {
    
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:EccSignResult.S)
}

// uint32 recover_param = 6;
inline void EccSignResult::clear_recover_param() {
  recover_param_ = 0u;
}
inline ::google::protobuf::uint32 EccSignResult::recover_param() const {
  // @@protoc_insertion_point(field_get:EccSignResult.recover_param)
  return recover_param_;
}
inline void EccSignResult::set_recover_param(::google::protobuf::uint32 value) {
  
  recover_param_ = value;
  // @@protoc_insertion_point(field_set:EccSignResult.recover_param)
}

// -------------------------------------------------------------------

// EccGetPublicKeyRequest

// string hdPath = 1;
inline void EccGetPublicKeyRequest::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetPublicKeyRequest::hdpath() const {
  // @@protoc_insertion_point(field_get:EccGetPublicKeyRequest.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccGetPublicKeyRequest::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetPublicKeyRequest.hdPath)
}
#if LANG_CXX11
inline void EccGetPublicKeyRequest::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetPublicKeyRequest.hdPath)
}
#endif
inline void EccGetPublicKeyRequest::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetPublicKeyRequest.hdPath)
}
inline void EccGetPublicKeyRequest::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetPublicKeyRequest.hdPath)
}
inline ::std::string* EccGetPublicKeyRequest::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccGetPublicKeyRequest.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetPublicKeyRequest::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccGetPublicKeyRequest.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetPublicKeyRequest::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccGetPublicKeyRequest.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccGetPublicKeyRequest::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccGetPublicKeyRequest::algorithm() const {
  // @@protoc_insertion_point(field_get:EccGetPublicKeyRequest.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccGetPublicKeyRequest::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccGetPublicKeyRequest.algorithm)
}

// -------------------------------------------------------------------

// EccGetPublicKeyReply

// string hdPath = 1;
inline void EccGetPublicKeyReply::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetPublicKeyReply::hdpath() const {
  // @@protoc_insertion_point(field_get:EccGetPublicKeyReply.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccGetPublicKeyReply::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetPublicKeyReply.hdPath)
}
#if LANG_CXX11
inline void EccGetPublicKeyReply::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetPublicKeyReply.hdPath)
}
#endif
inline void EccGetPublicKeyReply::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetPublicKeyReply.hdPath)
}
inline void EccGetPublicKeyReply::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetPublicKeyReply.hdPath)
}
inline ::std::string* EccGetPublicKeyReply::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccGetPublicKeyReply.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetPublicKeyReply::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccGetPublicKeyReply.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetPublicKeyReply::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccGetPublicKeyReply.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccGetPublicKeyReply::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccGetPublicKeyReply::algorithm() const {
  // @@protoc_insertion_point(field_get:EccGetPublicKeyReply.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccGetPublicKeyReply::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccGetPublicKeyReply.algorithm)
}

// bytes pubkey = 3;
inline void EccGetPublicKeyReply::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetPublicKeyReply::pubkey() const {
  // @@protoc_insertion_point(field_get:EccGetPublicKeyReply.pubkey)
  return pubkey_.GetNoArena();
}
inline void EccGetPublicKeyReply::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetPublicKeyReply.pubkey)
}
#if LANG_CXX11
inline void EccGetPublicKeyReply::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetPublicKeyReply.pubkey)
}
#endif
inline void EccGetPublicKeyReply::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetPublicKeyReply.pubkey)
}
inline void EccGetPublicKeyReply::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetPublicKeyReply.pubkey)
}
inline ::std::string* EccGetPublicKeyReply::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccGetPublicKeyReply.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetPublicKeyReply::release_pubkey() {
  // @@protoc_insertion_point(field_release:EccGetPublicKeyReply.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetPublicKeyReply::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccGetPublicKeyReply.pubkey)
}

// -------------------------------------------------------------------

// EccGetExtendedPublicKeyRequest

// string hdPath = 1;
inline void EccGetExtendedPublicKeyRequest::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetExtendedPublicKeyRequest::hdpath() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyRequest.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccGetExtendedPublicKeyRequest::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyRequest.hdPath)
}
#if LANG_CXX11
inline void EccGetExtendedPublicKeyRequest::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetExtendedPublicKeyRequest.hdPath)
}
#endif
inline void EccGetExtendedPublicKeyRequest::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetExtendedPublicKeyRequest.hdPath)
}
inline void EccGetExtendedPublicKeyRequest::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetExtendedPublicKeyRequest.hdPath)
}
inline ::std::string* EccGetExtendedPublicKeyRequest::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccGetExtendedPublicKeyRequest.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetExtendedPublicKeyRequest::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccGetExtendedPublicKeyRequest.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetExtendedPublicKeyRequest::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccGetExtendedPublicKeyRequest.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccGetExtendedPublicKeyRequest::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccGetExtendedPublicKeyRequest::algorithm() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyRequest.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccGetExtendedPublicKeyRequest::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyRequest.algorithm)
}

// -------------------------------------------------------------------

// EccGetExtendedPublicKeyReply

// string hdPath = 1;
inline void EccGetExtendedPublicKeyReply::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetExtendedPublicKeyReply::hdpath() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyReply.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccGetExtendedPublicKeyReply::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyReply.hdPath)
}
#if LANG_CXX11
inline void EccGetExtendedPublicKeyReply::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetExtendedPublicKeyReply.hdPath)
}
#endif
inline void EccGetExtendedPublicKeyReply::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetExtendedPublicKeyReply.hdPath)
}
inline void EccGetExtendedPublicKeyReply::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetExtendedPublicKeyReply.hdPath)
}
inline ::std::string* EccGetExtendedPublicKeyReply::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccGetExtendedPublicKeyReply.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetExtendedPublicKeyReply::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccGetExtendedPublicKeyReply.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetExtendedPublicKeyReply::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccGetExtendedPublicKeyReply.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccGetExtendedPublicKeyReply::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccGetExtendedPublicKeyReply::algorithm() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyReply.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccGetExtendedPublicKeyReply::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyReply.algorithm)
}

// bytes pubkey = 3;
inline void EccGetExtendedPublicKeyReply::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetExtendedPublicKeyReply::pubkey() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyReply.pubkey)
  return pubkey_.GetNoArena();
}
inline void EccGetExtendedPublicKeyReply::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyReply.pubkey)
}
#if LANG_CXX11
inline void EccGetExtendedPublicKeyReply::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetExtendedPublicKeyReply.pubkey)
}
#endif
inline void EccGetExtendedPublicKeyReply::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetExtendedPublicKeyReply.pubkey)
}
inline void EccGetExtendedPublicKeyReply::set_pubkey(const void* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetExtendedPublicKeyReply.pubkey)
}
inline ::std::string* EccGetExtendedPublicKeyReply::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccGetExtendedPublicKeyReply.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetExtendedPublicKeyReply::release_pubkey() {
  // @@protoc_insertion_point(field_release:EccGetExtendedPublicKeyReply.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetExtendedPublicKeyReply::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccGetExtendedPublicKeyReply.pubkey)
}

// bytes chainCode = 4;
inline void EccGetExtendedPublicKeyReply::clear_chaincode() {
  chaincode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccGetExtendedPublicKeyReply::chaincode() const {
  // @@protoc_insertion_point(field_get:EccGetExtendedPublicKeyReply.chainCode)
  return chaincode_.GetNoArena();
}
inline void EccGetExtendedPublicKeyReply::set_chaincode(const ::std::string& value) {
  
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccGetExtendedPublicKeyReply.chainCode)
}
#if LANG_CXX11
inline void EccGetExtendedPublicKeyReply::set_chaincode(::std::string&& value) {
  
  chaincode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccGetExtendedPublicKeyReply.chainCode)
}
#endif
inline void EccGetExtendedPublicKeyReply::set_chaincode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccGetExtendedPublicKeyReply.chainCode)
}
inline void EccGetExtendedPublicKeyReply::set_chaincode(const void* value, size_t size) {
  
  chaincode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccGetExtendedPublicKeyReply.chainCode)
}
inline ::std::string* EccGetExtendedPublicKeyReply::mutable_chaincode() {
  
  // @@protoc_insertion_point(field_mutable:EccGetExtendedPublicKeyReply.chainCode)
  return chaincode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccGetExtendedPublicKeyReply::release_chaincode() {
  // @@protoc_insertion_point(field_release:EccGetExtendedPublicKeyReply.chainCode)
  
  return chaincode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccGetExtendedPublicKeyReply::set_allocated_chaincode(::std::string* chaincode) {
  if (chaincode != NULL) {
    
  } else {
    
  }
  chaincode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chaincode);
  // @@protoc_insertion_point(field_set_allocated:EccGetExtendedPublicKeyReply.chainCode)
}

// -------------------------------------------------------------------

// EccMultiplyRequest

// string hdPath = 1;
inline void EccMultiplyRequest::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyRequest::hdpath() const {
  // @@protoc_insertion_point(field_get:EccMultiplyRequest.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccMultiplyRequest::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyRequest.hdPath)
}
#if LANG_CXX11
inline void EccMultiplyRequest::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyRequest.hdPath)
}
#endif
inline void EccMultiplyRequest::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyRequest.hdPath)
}
inline void EccMultiplyRequest::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyRequest.hdPath)
}
inline ::std::string* EccMultiplyRequest::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyRequest.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyRequest::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccMultiplyRequest.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyRequest::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyRequest.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccMultiplyRequest::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccMultiplyRequest::algorithm() const {
  // @@protoc_insertion_point(field_get:EccMultiplyRequest.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccMultiplyRequest::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccMultiplyRequest.algorithm)
}

// bytes input_pubkey = 3;
inline void EccMultiplyRequest::clear_input_pubkey() {
  input_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyRequest::input_pubkey() const {
  // @@protoc_insertion_point(field_get:EccMultiplyRequest.input_pubkey)
  return input_pubkey_.GetNoArena();
}
inline void EccMultiplyRequest::set_input_pubkey(const ::std::string& value) {
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyRequest.input_pubkey)
}
#if LANG_CXX11
inline void EccMultiplyRequest::set_input_pubkey(::std::string&& value) {
  
  input_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyRequest.input_pubkey)
}
#endif
inline void EccMultiplyRequest::set_input_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyRequest.input_pubkey)
}
inline void EccMultiplyRequest::set_input_pubkey(const void* value, size_t size) {
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyRequest.input_pubkey)
}
inline ::std::string* EccMultiplyRequest::mutable_input_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyRequest.input_pubkey)
  return input_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyRequest::release_input_pubkey() {
  // @@protoc_insertion_point(field_release:EccMultiplyRequest.input_pubkey)
  
  return input_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyRequest::set_allocated_input_pubkey(::std::string* input_pubkey) {
  if (input_pubkey != NULL) {
    
  } else {
    
  }
  input_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyRequest.input_pubkey)
}

// -------------------------------------------------------------------

// EccMultiplyReply

// string hdPath = 1;
inline void EccMultiplyReply::clear_hdpath() {
  hdpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyReply::hdpath() const {
  // @@protoc_insertion_point(field_get:EccMultiplyReply.hdPath)
  return hdpath_.GetNoArena();
}
inline void EccMultiplyReply::set_hdpath(const ::std::string& value) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyReply.hdPath)
}
#if LANG_CXX11
inline void EccMultiplyReply::set_hdpath(::std::string&& value) {
  
  hdpath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyReply.hdPath)
}
#endif
inline void EccMultiplyReply::set_hdpath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyReply.hdPath)
}
inline void EccMultiplyReply::set_hdpath(const char* value, size_t size) {
  
  hdpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyReply.hdPath)
}
inline ::std::string* EccMultiplyReply::mutable_hdpath() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyReply.hdPath)
  return hdpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyReply::release_hdpath() {
  // @@protoc_insertion_point(field_release:EccMultiplyReply.hdPath)
  
  return hdpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyReply::set_allocated_hdpath(::std::string* hdpath) {
  if (hdpath != NULL) {
    
  } else {
    
  }
  hdpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hdpath);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyReply.hdPath)
}

// .EccAlgorithm algorithm = 2;
inline void EccMultiplyReply::clear_algorithm() {
  algorithm_ = 0;
}
inline ::EccAlgorithm EccMultiplyReply::algorithm() const {
  // @@protoc_insertion_point(field_get:EccMultiplyReply.algorithm)
  return static_cast< ::EccAlgorithm >(algorithm_);
}
inline void EccMultiplyReply::set_algorithm(::EccAlgorithm value) {
  
  algorithm_ = value;
  // @@protoc_insertion_point(field_set:EccMultiplyReply.algorithm)
}

// bytes input_pubkey = 3;
inline void EccMultiplyReply::clear_input_pubkey() {
  input_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyReply::input_pubkey() const {
  // @@protoc_insertion_point(field_get:EccMultiplyReply.input_pubkey)
  return input_pubkey_.GetNoArena();
}
inline void EccMultiplyReply::set_input_pubkey(const ::std::string& value) {
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyReply.input_pubkey)
}
#if LANG_CXX11
inline void EccMultiplyReply::set_input_pubkey(::std::string&& value) {
  
  input_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyReply.input_pubkey)
}
#endif
inline void EccMultiplyReply::set_input_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyReply.input_pubkey)
}
inline void EccMultiplyReply::set_input_pubkey(const void* value, size_t size) {
  
  input_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyReply.input_pubkey)
}
inline ::std::string* EccMultiplyReply::mutable_input_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyReply.input_pubkey)
  return input_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyReply::release_input_pubkey() {
  // @@protoc_insertion_point(field_release:EccMultiplyReply.input_pubkey)
  
  return input_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyReply::set_allocated_input_pubkey(::std::string* input_pubkey) {
  if (input_pubkey != NULL) {
    
  } else {
    
  }
  input_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyReply.input_pubkey)
}

// bytes dev_pubkey = 4;
inline void EccMultiplyReply::clear_dev_pubkey() {
  dev_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyReply::dev_pubkey() const {
  // @@protoc_insertion_point(field_get:EccMultiplyReply.dev_pubkey)
  return dev_pubkey_.GetNoArena();
}
inline void EccMultiplyReply::set_dev_pubkey(const ::std::string& value) {
  
  dev_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyReply.dev_pubkey)
}
#if LANG_CXX11
inline void EccMultiplyReply::set_dev_pubkey(::std::string&& value) {
  
  dev_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyReply.dev_pubkey)
}
#endif
inline void EccMultiplyReply::set_dev_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dev_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyReply.dev_pubkey)
}
inline void EccMultiplyReply::set_dev_pubkey(const void* value, size_t size) {
  
  dev_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyReply.dev_pubkey)
}
inline ::std::string* EccMultiplyReply::mutable_dev_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyReply.dev_pubkey)
  return dev_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyReply::release_dev_pubkey() {
  // @@protoc_insertion_point(field_release:EccMultiplyReply.dev_pubkey)
  
  return dev_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyReply::set_allocated_dev_pubkey(::std::string* dev_pubkey) {
  if (dev_pubkey != NULL) {
    
  } else {
    
  }
  dev_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dev_pubkey);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyReply.dev_pubkey)
}

// bytes result = 5;
inline void EccMultiplyReply::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EccMultiplyReply::result() const {
  // @@protoc_insertion_point(field_get:EccMultiplyReply.result)
  return result_.GetNoArena();
}
inline void EccMultiplyReply::set_result(const ::std::string& value) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EccMultiplyReply.result)
}
#if LANG_CXX11
inline void EccMultiplyReply::set_result(::std::string&& value) {
  
  result_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EccMultiplyReply.result)
}
#endif
inline void EccMultiplyReply::set_result(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EccMultiplyReply.result)
}
inline void EccMultiplyReply::set_result(const void* value, size_t size) {
  
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EccMultiplyReply.result)
}
inline ::std::string* EccMultiplyReply::mutable_result() {
  
  // @@protoc_insertion_point(field_mutable:EccMultiplyReply.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EccMultiplyReply::release_result() {
  // @@protoc_insertion_point(field_release:EccMultiplyReply.result)
  
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EccMultiplyReply::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    
  } else {
    
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:EccMultiplyReply.result)
}

// -------------------------------------------------------------------

// EraseDataRequest

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::DeviceMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DeviceMode>() {
  return ::DeviceMode_descriptor();
}
template <> struct is_proto_enum< ::LockState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LockState>() {
  return ::LockState_descriptor();
}
template <> struct is_proto_enum< ::EccAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EccAlgorithm>() {
  return ::EccAlgorithm_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
