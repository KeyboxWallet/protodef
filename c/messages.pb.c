/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9.1 at Tue May 12 17:43:19 2020. */

#include "messages.pb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif



const pb_field_t RequestRejected_fields[4] = {
    PB_FIELD(  1, UINT32  , SINGULAR, STATIC  , FIRST, RequestRejected, requestId, requestId, 0),
    PB_FIELD(  2, INT32   , SINGULAR, STATIC  , OTHER, RequestRejected, errCode, requestId, 0),
    PB_FIELD(  3, STRING  , SINGULAR, STATIC  , OTHER, RequestRejected, errMessage, errCode, 0),
    PB_LAST_FIELD
};

const pb_field_t GenericConfirmReply_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t GetModeAndVersionRequest_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t GetModeAndVersionReply_fields[5] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, GetModeAndVersionReply, mode, mode, 0),
    PB_FIELD(  2, STRING  , SINGULAR, STATIC  , OTHER, GetModeAndVersionReply, firmwareVersion, mode, 0),
    PB_FIELD(  3, STRING  , SINGULAR, STATIC  , OTHER, GetModeAndVersionReply, deviceSerialNo, firmwareVersion, 0),
    PB_FIELD(  4, UENUM   , SINGULAR, STATIC  , OTHER, GetModeAndVersionReply, isLocked, deviceSerialNo, 0),
    PB_LAST_FIELD
};

const pb_field_t UpgradeStartRequest_fields[3] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, UpgradeStartRequest, firmwareVersion, firmwareVersion, 0),
    PB_FIELD(  2, BYTES   , SINGULAR, STATIC  , OTHER, UpgradeStartRequest, sha256hash, firmwareVersion, 0),
    PB_LAST_FIELD
};

const pb_field_t SendUpgradeFirmware_fields[5] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, SendUpgradeFirmware, firmwareVersion, firmwareVersion, 0),
    PB_FIELD(  2, BYTES   , SINGULAR, STATIC  , OTHER, SendUpgradeFirmware, sha256hash, firmwareVersion, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, SendUpgradeFirmware, signature, sha256hash, 0),
    PB_FIELD(  4, BYTES   , SINGULAR, CALLBACK, OTHER, SendUpgradeFirmware, firmware, signature, 0),
    PB_LAST_FIELD
};

const pb_field_t WriteSerialNo_fields[2] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, WriteSerialNo, deviceSerialNo, deviceSerialNo, 0),
    PB_LAST_FIELD
};

const pb_field_t WriteSerialNoReply_fields[3] = {
    PB_FIELD(  1, BOOL    , SINGULAR, STATIC  , FIRST, WriteSerialNoReply, writeSuccess, writeSuccess, 0),
    PB_FIELD(  2, STRING  , SINGULAR, STATIC  , OTHER, WriteSerialNoReply, deviceSerialNo, writeSuccess, 0),
    PB_LAST_FIELD
};

const pb_field_t LockSerialNo_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t lockSerialNoReply_fields[3] = {
    PB_FIELD(  1, BOOL    , SINGULAR, STATIC  , FIRST, lockSerialNoReply, lockSuccess, lockSuccess, 0),
    PB_FIELD(  2, STRING  , SINGULAR, STATIC  , OTHER, lockSerialNoReply, deviceSerialNo, lockSuccess, 0),
    PB_LAST_FIELD
};

const pb_field_t EccSignOptions_fields[3] = {
    PB_FIELD(  1, BOOL    , SINGULAR, STATIC  , FIRST, EccSignOptions, rfc6979, rfc6979, 0),
    PB_FIELD(  2, BOOL    , SINGULAR, STATIC  , OTHER, EccSignOptions, graphene_canonize, rfc6979, 0),
    PB_LAST_FIELD
};

const pb_field_t EccSignRequest_fields[5] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccSignRequest, hdPath, hdPath, 0),
    PB_FIELD(  2, BYTES   , SINGULAR, STATIC  , OTHER, EccSignRequest, hash, hdPath, 0),
    PB_FIELD(  3, UENUM   , SINGULAR, STATIC  , OTHER, EccSignRequest, algorithm, hash, 0),
    PB_FIELD(  4, MESSAGE , SINGULAR, STATIC  , OTHER, EccSignRequest, options, algorithm, &EccSignOptions_fields),
    PB_LAST_FIELD
};

const pb_field_t EccSignResult_fields[7] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccSignResult, hdPath, hdPath, 0),
    PB_FIELD(  2, BYTES   , SINGULAR, STATIC  , OTHER, EccSignResult, pubkey, hdPath, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, EccSignResult, hash, pubkey, 0),
    PB_FIELD(  4, BYTES   , SINGULAR, STATIC  , OTHER, EccSignResult, R, hash, 0),
    PB_FIELD(  5, BYTES   , SINGULAR, STATIC  , OTHER, EccSignResult, S, R, 0),
    PB_FIELD(  6, UINT32  , SINGULAR, STATIC  , OTHER, EccSignResult, recover_param, S, 0),
    PB_LAST_FIELD
};

const pb_field_t EccGetPublicKeyRequest_fields[3] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccGetPublicKeyRequest, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccGetPublicKeyRequest, algorithm, hdPath, 0),
    PB_LAST_FIELD
};

const pb_field_t EccGetPublicKeyReply_fields[4] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccGetPublicKeyReply, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccGetPublicKeyReply, algorithm, hdPath, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, EccGetPublicKeyReply, pubkey, algorithm, 0),
    PB_LAST_FIELD
};

const pb_field_t EccGetExtendedPublicKeyRequest_fields[3] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccGetExtendedPublicKeyRequest, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccGetExtendedPublicKeyRequest, algorithm, hdPath, 0),
    PB_LAST_FIELD
};

const pb_field_t EccGetExtendedPublicKeyReply_fields[5] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccGetExtendedPublicKeyReply, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccGetExtendedPublicKeyReply, algorithm, hdPath, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, EccGetExtendedPublicKeyReply, pubkey, algorithm, 0),
    PB_FIELD(  4, BYTES   , SINGULAR, STATIC  , OTHER, EccGetExtendedPublicKeyReply, chainCode, pubkey, 0),
    PB_LAST_FIELD
};

const pb_field_t EccMultiplyRequest_fields[4] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccMultiplyRequest, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccMultiplyRequest, algorithm, hdPath, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, EccMultiplyRequest, input_pubkey, algorithm, 0),
    PB_LAST_FIELD
};

const pb_field_t EccMultiplyReply_fields[6] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, EccMultiplyReply, hdPath, hdPath, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, EccMultiplyReply, algorithm, hdPath, 0),
    PB_FIELD(  3, BYTES   , SINGULAR, STATIC  , OTHER, EccMultiplyReply, input_pubkey, algorithm, 0),
    PB_FIELD(  4, BYTES   , SINGULAR, STATIC  , OTHER, EccMultiplyReply, dev_pubkey, input_pubkey, 0),
    PB_FIELD(  5, BYTES   , SINGULAR, STATIC  , OTHER, EccMultiplyReply, result, dev_pubkey, 0),
    PB_LAST_FIELD
};

const pb_field_t EraseDataRequest_fields[1] = {
    PB_LAST_FIELD
};





/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(UpgradeStartRequest, sha256hash) < 65536 && pb_membersize(SendUpgradeFirmware, sha256hash) < 65536 && pb_membersize(EccSignRequest, hash) < 65536 && pb_membersize(EccSignRequest, options) < 65536 && pb_membersize(EccSignResult, pubkey) < 65536 && pb_membersize(EccSignResult, hash) < 65536 && pb_membersize(EccSignResult, R) < 65536 && pb_membersize(EccSignResult, S) < 65536 && pb_membersize(EccGetPublicKeyReply, pubkey) < 65536 && pb_membersize(EccGetExtendedPublicKeyReply, pubkey) < 65536 && pb_membersize(EccGetExtendedPublicKeyReply, chainCode) < 65536 && pb_membersize(EccMultiplyRequest, input_pubkey) < 65536 && pb_membersize(EccMultiplyReply, input_pubkey) < 65536 && pb_membersize(EccMultiplyReply, dev_pubkey) < 65536 && pb_membersize(EccMultiplyReply, result) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_RequestRejected_GenericConfirmReply_GetModeAndVersionRequest_GetModeAndVersionReply_UpgradeStartRequest_SendUpgradeFirmware_WriteSerialNo_WriteSerialNoReply_LockSerialNo_lockSerialNoReply_EccSignOptions_EccSignRequest_EccSignResult_EccGetPublicKeyRequest_EccGetPublicKeyReply_EccGetExtendedPublicKeyRequest_EccGetExtendedPublicKeyReply_EccMultiplyRequest_EccMultiplyReply_EraseDataRequest)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
#error Field descriptor for EccMultiplyReply.result is too large. Define PB_FIELD_16BIT to fix this.
#endif


/* @@protoc_insertion_point(eof) */
